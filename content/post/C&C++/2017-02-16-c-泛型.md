---
layout: post
title: C++泛型
date: '2017-02-16 15:39'
categories: ["C&C++"]
---

# 泛型方法
```
template <typename T>
int compare(const T &v1, const T &v2)
{
   if (v1 < v2) return -1;
   if (v2 < v1) return 1;
   return 0;
}
```
a. 模板定义以关键字 template 开始，后接模板形参表，模板形参表是用尖括号括住的一个或多个模板形参的列表，形参之间以逗号分隔。 模板形参表不能为空。

b. 模板形参表很像函数形参表，函数形参表定义了特定类型的局部变量但并不初始化那些变量，在运行时再提供实参来初始化形参。

c. 模板形参可以是表示类型的类型形参，也可以是表示常量表达式的非类型形参。非类型形参跟在类型说明符之后声明, 类型形参跟在关键字 class 或 typename 之后定义，例如，class T 是名为 T 的类型形参，在这里 class 和 typename 没有区别。

使用函数模板时，编译器会推断哪个（或哪些）模板实参绑定到模板形参。一旦编译器确定了实际的模板实参，就称它实例化了函数模板的一个实例。实质上，编译器将确定用什么类型代替每个类型形参，以及用什么值代替每个非类型形参。推导出实际模板实参后，编译器使用实参代替相应的模板形参产生编译该版本的函数。编译器承担了为我们使用的每种类型而编写函数的单调工作。

#泛型类
```
template <class T1, class T2 >
class A {
private:
  int a;
  T1 b; //成员变量也可以用模板参数
public:
  int fun1(T1 x, int y );
  T2 fun2(T1 x, T2 y);
}
//类实现部分
template <class T1, class T2 >
int A<T1>:: fun1(T1 x, int y )
{
  //实现……
}

template <class T1, class T2 >
T2 A<T1,T2>:: fun2(T1 x, T2 y)
{
  //实现……
}

//使用类A
int main( ) {
//定义对象a,并用int替换T1, float替换T2
A<int, float> a;
//实例化a,调用a的属性和方法……
}
```

类模板:类模板也是模板，因此必须以关键字 template 开头，后接模板形参表。

a. 除了模板形参表外，类模板的定义看起来与任意其他类问相似。类模板可以定义数据成员、函数成员和类型成员，也可以使用访问标号控制对成员的访问，还可以定义构造函数和析构函数等等。在类和类成员的定义中，可以使用模板形参作为类型或值的占位符，在使用类时再提供那些类型或值。

b. 与调用函数模板形成对比，使用类模板时，必须为模板形参显式指定实参.编译器使用实参来实例化这个类的特定类型版本。
